package pentest

import (
	"context"
	"fmt"
	"time"

	"mcpxray/internal/libmcp"
	"mcpxray/internal/llm"
	"mcpxray/proto"

	"github.com/modelcontextprotocol/go-sdk/mcp"
)

type PentestTool struct {
	configPath string
	llmClient  *llm.LLMClient
}

func NewPentestTool(configPath string, model string) (*PentestTool, error) {
	var llmClient *llm.LLMClient
	var err error
	if model != "" {
		llmClient, err = llm.NewLLMClientFromEnvWithModel(model, 30*time.Second)
		if err != nil {
			return nil, err
		}
	}
	return &PentestTool{
		configPath: configPath,
		llmClient:  llmClient,
	}, nil
}

func (t *PentestTool) Pentest(ctx context.Context, testPlanFile string) ([]proto.Finding, error) {
	// Parse configPath
	servers, err := libmcp.NewConfigParser(t.configPath).Parse()
	if err != nil {
		return nil, err
	}

	var allFindings []proto.Finding

	for _, server := range servers {
		// Create SDK session directly
		session, err := libmcp.NewSDKSession(ctx, server)
		if err != nil {
			// Skip servers that can't be connected (e.g., HTTP/SSE not supported by SDK)
			continue
		}
		defer session.Close()

		// Get tools using SDK
		toolsList, err := session.Session.ListTools(ctx, &mcp.ListToolsParams{})
		if err != nil {
			return nil, err
		}
		tools := toolsList.Tools

		if len(tools) == 0 {
			continue
		}

		// Convert []*mcp.Tool to []mcp.Tool
		toolsSlice := make([]mcp.Tool, len(tools))
		for i, tool := range tools {
			toolsSlice[i] = *tool
		}

		// TODO: FIXME, do not restrict the number of tools to 3
		if testPlanFile == "" {
			testPlanFile, err = t.GeneratePentestPlan(ctx, toolsSlice[:1])
			if err != nil {
				return nil, fmt.Errorf("failed to generate pentest plan: %w", err)
			}
		}

		findings, err := t.ExecuteTestPlan(ctx, testPlanFile, session.Session, server.Name)
		if err != nil {
			return nil, fmt.Errorf("failed to execute pentest plan: %w", err)
		}
		allFindings = append(allFindings, findings...)
	}

	return allFindings, nil
}
